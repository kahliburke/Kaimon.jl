import{_ as e,o as a,c as i,a3 as n}from"./chunks/framework.CL3B3Tmm.js";const u=JSON.parse('{"title":"Session Management","description":"","frontmatter":{},"headers":[],"relativePath":"sessions.md","filePath":"sessions.md","lastUpdated":null}'),t={name:"sessions.md"};function o(l,s,p,r,h,c){return a(),i("div",null,[...s[0]||(s[0]=[n(`<h1 id="Session-Management" tabindex="-1">Session Management <a class="header-anchor" href="#Session-Management" aria-label="Permalink to &quot;Session Management {#Session-Management}&quot;">​</a></h1><p>Kaimon connects AI agents to live Julia REPLs. Each connected REPL is a <strong>session</strong> – an independent Julia process with its own state, loaded packages, and working directory. Agents execute code, inspect types, run tests, and more by routing requests to a specific session.</p><h2 id="What-Is-a-Session?" tabindex="-1">What Is a Session? <a class="header-anchor" href="#What-Is-a-Session?" aria-label="Permalink to &quot;What Is a Session? {#What-Is-a-Session?}&quot;">​</a></h2><p>A session represents a single Julia REPL that has connected to the Kaimon server. Each session has:</p><ul><li><p>A unique <strong>8-character session key</strong> (e.g., <code>a3f8b2c1</code>) used to identify and target it.</p></li><li><p>Its own Julia process with independent module state, variables, and loaded packages.</p></li><li><p>A health status indicating whether it is responsive.</p></li></ul><p>Multiple sessions can be connected simultaneously, allowing agents to work across different projects or environments at the same time.</p><h2 id="Starting-a-Session" tabindex="-1">Starting a Session <a class="header-anchor" href="#Starting-a-Session" aria-label="Permalink to &quot;Starting a Session {#Starting-a-Session}&quot;">​</a></h2><p>There are three ways to connect a REPL, ranging from manual to fully automatic.</p><h3 id="manual" tabindex="-1">Manual <a class="header-anchor" href="#manual" aria-label="Permalink to &quot;Manual&quot;">​</a></h3><p>Call <code>Gate.serve()</code> in any running REPL:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Kaimon</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Gate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">serve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>This is non-blocking — the gate runs in a background task and the REPL remains interactive. Good for one-off connections or scripts.</p><h3 id="Per-project-auto-connect" tabindex="-1">Per-project auto-connect <a class="header-anchor" href="#Per-project-auto-connect" aria-label="Permalink to &quot;Per-project auto-connect {#Per-project-auto-connect}&quot;">​</a></h3><p>The Config tab&#39;s onboarding flow writes a <code>.julia-startup.jl</code> file into your project directory. Load it with Julia&#39;s <code>--load=</code> flag and the REPL auto-connects whenever it launches in that directory:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">julia</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --load=.julia-startup.jl</span></span></code></pre></div><p>The generated file loads Revise and calls <code>Gate.serve()</code>, both wrapped in <code>try/catch</code> so startup succeeds even when Kaimon is not running:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># .julia-startup.jl</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Revise</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    @info</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ℹ Revise not loaded (optional)&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Kaimon</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Gate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">serve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    @warn</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Kaimon Gate failed to start&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> exception </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><h3 id="Global-auto-connect" tabindex="-1">Global auto-connect <a class="header-anchor" href="#Global-auto-connect" aria-label="Permalink to &quot;Global auto-connect {#Global-auto-connect}&quot;">​</a></h3><p>The Config tab&#39;s <strong>&quot;Julia startup.jl (global gate)&quot;</strong> option appends the same snippet to <code>~/.julia/config/startup.jl</code>. After that, every Julia session on your machine auto-connects to Kaimon without any project-level setup.</p><p>Each REPL that calls <code>Gate.serve()</code> registers as a separate session with its own session key.</p><h2 id="Session-Routing" tabindex="-1">Session Routing <a class="header-anchor" href="#Session-Routing" aria-label="Permalink to &quot;Session Routing {#Session-Routing}&quot;">​</a></h2><p>When only one session is connected, agents do not need to specify a target – all requests are routed to the single active session automatically.</p><p>When <strong>multiple sessions</strong> are connected, agents must specify which session to target by providing the 8-character session key. Every tool that executes code or inspects state accepts a <code>session</code> (or <code>ses</code>) parameter for this purpose:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ex(e=&quot;using LinearAlgebra&quot;, ses=&quot;a3f8b2c1&quot;)</span></span>
<span class="line"><span>run_tests(session=&quot;a3f8b2c1&quot;)</span></span>
<span class="line"><span>type_info(type_expr=&quot;Matrix{Float64}&quot;, session=&quot;a3f8b2c1&quot;)</span></span></code></pre></div><p>If an agent omits the session key when multiple sessions are connected, the server returns an error indicating that a session must be specified.</p><h2 id="Viewing-Sessions-in-the-TUI" tabindex="-1">Viewing Sessions in the TUI <a class="header-anchor" href="#Viewing-Sessions-in-the-TUI" aria-label="Permalink to &quot;Viewing Sessions in the TUI {#Viewing-Sessions-in-the-TUI}&quot;">​</a></h2><p>The TUI (terminal user interface) includes a <strong>Sessions tab</strong> that displays all connected REPLs. For each session, it shows:</p><ul><li><p>The session key.</p></li><li><p>Connection status and health (based on periodic heartbeat checks).</p></li><li><p>The Julia version and active project environment.</p></li></ul><p>This tab provides a real-time overview of which REPLs are available for agents to target.</p><h2 id="Restarting-a-Session" tabindex="-1">Restarting a Session <a class="header-anchor" href="#Restarting-a-Session" aria-label="Permalink to &quot;Restarting a Session {#Restarting-a-Session}&quot;">​</a></h2><p>To restart a session, use the <code>manage_repl</code> tool with the <code>restart</code> command:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>manage_repl(command=&quot;restart&quot;)</span></span>
<span class="line"><span>manage_repl(command=&quot;restart&quot;, session=&quot;a3f8b2c1&quot;)</span></span></code></pre></div><p>Restart replaces the Julia process in-place using <code>execvp</code>, which swaps the running process image without spawning a child. This means:</p><ul><li><p>The process ID stays the same.</p></li><li><p>All Julia state is cleared (a fresh session begins).</p></li><li><p>The session key is preserved, so agents can continue targeting the same key.</p></li><li><p>Revise and other packages are reloaded from scratch.</p></li></ul><p>Use restart when Revise fails to pick up structural changes, or when the session state has become corrupted.</p><h2 id="Shutting-Down-a-Session" tabindex="-1">Shutting Down a Session <a class="header-anchor" href="#Shutting-Down-a-Session" aria-label="Permalink to &quot;Shutting Down a Session {#Shutting-Down-a-Session}&quot;">​</a></h2><p>To cleanly disconnect a session, use the <code>manage_repl</code> tool with the <code>shutdown</code> command:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>manage_repl(command=&quot;shutdown&quot;)</span></span>
<span class="line"><span>manage_repl(command=&quot;shutdown&quot;, session=&quot;a3f8b2c1&quot;)</span></span></code></pre></div><p>This stops the session permanently. The session key is deregistered, and the REPL disconnects from the server. The Julia process exits.</p><h2 id="auto-discovery" tabindex="-1">Auto-Discovery <a class="header-anchor" href="#auto-discovery" aria-label="Permalink to &quot;Auto-Discovery&quot;">​</a></h2><p>Kaimon uses a file-based discovery mechanism. When a REPL calls <code>Gate.serve()</code>, it writes a ZMQ socket file to:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>~/.cache/kaimon/sock/</span></span></code></pre></div><p>The Kaimon server watches this directory for new socket files. When a new file appears, the server automatically connects to the corresponding REPL and registers it as a session. When a socket file is removed (e.g., on shutdown), the session is deregistered.</p><p>This design means sessions can start and stop independently of the server – the server discovers them as they appear.</p>`,44)])])}const g=e(t,[["render",o]]);export{u as __pageData,g as default};
