# Getting Started

## 1. Launch Kaimon

```bash
./bin/kaimon
```

On the first run, Kaimon installs dependencies, precompiles, then launches the
**setup wizard** — an interactive TUI that walks you through security mode, API
key generation, and port selection:

![Kaimon setup wizard](./assets/kaimon_wizard.gif)

Once setup completes, the dashboard opens:

![Kaimon dashboard](./assets/kaimon_overview.gif)

The dashboard shows connected REPL sessions, live tool call activity, server
logs, search index status, and configuration — all from one place.

### Launch options

```bash
./bin/kaimon --port 3000       # custom port
./bin/kaimon --theme esper     # theme: kokaku, esper, motoko, neuromancer
./bin/kaimon --revise          # load Revise for live code reloading
```

## 2. Connect an MCP Client

Press **`c`** in the dashboard to open the **Config** tab. From there you can
generate and write MCP configuration for your editor with a single keypress —
no manual file editing needed.

![Kaimon config tab](./assets/kaimon_config.gif)

Supported clients: Claude Code, VS Code (Copilot/Continue), Cursor, Gemini
CLI, and KiloCode. The Config tab writes the correct config format for each
one, including your API key if running in authenticated mode.

## 3. Connect External REPLs

The **Gate** lets any Julia REPL register itself as a live session. Kaimon
discovers it automatically and shows it in the Sessions tab. There are three
ways to connect:

![Kaimon sessions](./assets/kaimon_sessions.gif)

### Option A — Manual (one-off)

Call `Gate.serve()` in any running REPL:

```julia
using Kaimon
Gate.serve()
```

This is non-blocking. The gate runs in the background and the REPL stays
interactive. Good for trying things out or for REPLs you start manually.

### Option B — Per-project auto-connect

The Config tab's **onboarding flow** writes a `.julia-startup.jl` file into
any directory you choose. Press **`o`** in the Config tab, enter a project
path, and Kaimon creates the file:

![Per-project gate setup](./assets/kaimon_startup_project.gif)

```julia
# .julia-startup.jl  (auto-generated by Kaimon)
# Kaimon Gate — auto-connect this REPL to the TUI server
try
    using Revise
catch e
    @info "ℹ Revise not loaded (optional)"
end
try
    using Kaimon
    Gate.serve()
catch e
    @warn "Kaimon Gate failed to start" exception = e
end
```

To load it automatically when starting Julia in that project, use the
`--load=` flag:

```bash
julia --load=.julia-startup.jl
```

You can set this as the default in your shell alias or launch script so every
REPL in that directory auto-connects. The `try/catch` blocks mean startup
succeeds normally even if Kaimon isn't running.

### Option C — Global auto-connect (every Julia session)

The Config tab's **"Julia startup.jl (global gate)"** option appends the same
Gate snippet to `~/.julia/config/startup.jl`. After that, every Julia session
on your machine auto-connects without any per-project setup:

![Global gate startup](./assets/kaimon_startup_global.gif)

```
Config tab → i (client list) → Julia startup.jl (global gate) → Enter
```

This is the lowest-friction option: start any Julia REPL and it appears in
Kaimon's Sessions tab within a second or two.

::: tip What does this startup file do?
It loads `Revise` so hot-reloading works automatically in every session.

It then calls `Gate.serve()` to register the REPL with Kaimon.

Both are wrapped in `try/catch` so Julia starts normally even if Kaimon isn't installed or the server isn't running.
:::

### Custom tools

REPLs can also expose **custom tools** that the AI agent can call — the Gate
reflects on your function signatures to generate MCP schemas automatically:

```julia
"""Return summary statistics for a dataset."""
function summarize(path::String, max_rows::Int=1000)
    # your domain logic
end

Gate.serve(tools=[Gate.GateTool("summarize", summarize)])
```

See [The Gate](gate.md) for the full custom tools guide.

## 4. Semantic Search

The **Search** tab connects to a local [Qdrant](https://qdrant.tech) instance
and manages vector indexes over your codebase. Once indexed, your AI agent can
search with natural language using the `qdrant_search_code` tool.

![Kaimon search](./assets/kaimon_search.gif)

Navigate to the Search tab (press **`4`**), select a collection, and run a
query. Kaimon chunks your source files, embeds them with a local Ollama model,
and stores the vectors in Qdrant — all from the TUI.

Requirements: [Qdrant](https://qdrant.tech/documentation/quick-start/) and
[Ollama](https://ollama.com) running locally. See
[Semantic Search](search.md) for setup and configuration.

## Next Steps

- [Tool Catalog](tools.md) — all available tools and their parameters
- [The Gate](gate.md) — connecting external processes and building custom tools
- [Architecture](architecture.md) — how the components fit together
- [Configuration](configuration.md) — security, preferences, and config files
